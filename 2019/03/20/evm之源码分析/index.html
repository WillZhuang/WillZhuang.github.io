<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>EVM之源码分析 | Zhuang&#39;s Diary</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="ethereum的虚拟机源码所有部分在core&#x2F;vm下。 去除测试总共有24个源码文件。 整个vm调用的入口在go-ethereum&#x2F;core&#x2F;state_transaction.go中。 我们主要是为了分析虚拟机源码，所以关于以太坊是如何进行交易转账忽略过去。 123456789101112131415161718192021222324252627282930313233func (st *S">
<meta property="og:type" content="article">
<meta property="og:title" content="EVM之源码分析">
<meta property="og:url" content="https://willzhuang.github.io/2019/03/20/evm%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="Zhuang&#39;s Diary">
<meta property="og:description" content="ethereum的虚拟机源码所有部分在core&#x2F;vm下。 去除测试总共有24个源码文件。 整个vm调用的入口在go-ethereum&#x2F;core&#x2F;state_transaction.go中。 我们主要是为了分析虚拟机源码，所以关于以太坊是如何进行交易转账忽略过去。 123456789101112131415161718192021222324252627282930313233func (st *S">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2019-03-20T02:39:42.000Z">
<meta property="article:modified_time" content="2019-03-20T01:35:15.000Z">
<meta property="article:author" content="Weiming Zhuang">
<meta property="article:tag" content="EVM">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Zhuang&#39;s Diary" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Zhuang&#39;s Diary</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://willzhuang.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-evm之源码分析" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/20/evm%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2019-03-20T02:39:42.000Z" itemprop="datePublished">2019-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      EVM之源码分析
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ethereum的虚拟机源码所有部分在core/vm下。 去除测试总共有24个源码文件。 整个vm调用的入口在go-ethereum/core/state_transaction.go中。 我们主要是为了分析虚拟机源码，所以关于以太坊是如何进行交易转账忽略过去。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(st *StateTransition)</span> <span class="title">TransitionDb</span><span class="params">()</span> <span class="params">(ret []<span class="keyword">byte</span>, usedGas <span class="keyword">uint64</span>, failed <span class="keyword">bool</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> err = st.preCheck(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	msg := st.msg</span><br><span class="line">	sender := vm.AccountRef(msg.From())</span><br><span class="line">	homestead := st.evm.ChainConfig().IsHomestead(st.evm.BlockNumber)</span><br><span class="line">	contractCreation := msg.To() == <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Pay intrinsic gas</span></span><br><span class="line">gas, err := IntrinsicGas(st.data, contractCreation, homestead)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err = st.useGas(gas); err != <span class="literal">nil</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="number">0</span>, <span class="literal">false</span>, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">	evm = st.evm</span><br><span class="line">	<span class="comment">// vm errors do not effect consensus and are therefor</span></span><br><span class="line">	<span class="comment">// not assigned to err, except for insufficient balance</span></span><br><span class="line">	<span class="comment">// error.</span></span><br><span class="line">	vmerr error</span><br><span class="line">)</span><br><span class="line"><span class="keyword">if</span> contractCreation &#123;</span><br><span class="line">	ret, _, st.gas, vmerr = evm.Create(sender, st.data, st.gas, st.value)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// Increment the nonce for the next transaction</span></span><br><span class="line">	st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+<span class="number">1</span>)</span><br><span class="line">	ret, st.gas, vmerr = evm.Call(sender, st.to(), st.data, st.gas, st.value)</span><br><span class="line">&#125;</span><br><span class="line">.........</span><br></pre></td></tr></table></figure>

<p>从上面的截图我们可以看出， 当以太坊的交易中to地址为nil时， 意味着部署合约， 那么就会调用evm.Create方法。 否则调用了evm.Call方法。 也就是说分析以太坊虚拟机源码时， 只要从这两个函数作为入口即可。</p>
<p>首先我们先看一下EVM数据结构:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> EVM <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// Context provides auxiliary blockchain related information</span></span><br><span class="line">	Context</span><br><span class="line">	<span class="comment">// StateDB是状态存储接口。 这个接口非常重要。 可以肯定的说evm中的大部分工作都是围绕这次接口进行的。</span></span><br><span class="line">	StateDB StateDB</span><br><span class="line">	<span class="comment">// 记录当前调用的深度</span></span><br><span class="line">	depth <span class="keyword">int</span></span><br><span class="line">	<span class="comment">// 记录链的配置 主要是以太坊经理过几次分叉和提案 为了兼容之前的区块信息</span></span><br><span class="line"> 	<span class="comment">// 所以做了一些兼容 移植的时候我们只考虑最新版本的内容</span></span><br><span class="line">	chainConfig *params.ChainConfig</span><br><span class="line">	<span class="comment">// 这个参数 对我们移植过程中的意义不是很大</span></span><br><span class="line">	chainRules params.Rules</span><br><span class="line">	<span class="comment">// 这个是虚拟机的一些配置参数 是创建解释器的初始化参数 比如所有操作码对应的函数也是在此处配置的</span></span><br><span class="line">	vmConfig Config</span><br><span class="line"> 	<span class="comment">// 解释器对象 它是整个进行虚拟机代码执行的地方。</span></span><br><span class="line">	interpreter *Interpreter</span><br><span class="line"> 	 <span class="comment">// 用来终止代码执行</span></span><br><span class="line">	abort <span class="keyword">int32</span></span><br><span class="line">	<span class="comment">// callGasTemp holds the gas available for the current call. This is needed because the</span></span><br><span class="line">	<span class="comment">// available gas is calculated in gasCall* according to the 63/64 rule and later</span></span><br><span class="line">	<span class="comment">// applied in opCall*.</span></span><br><span class="line">	callGasTemp <span class="keyword">uint64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先看一看创建EVM的方法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewEVM</span><span class="params">(ctx Context, statedb StateDB, chainConfig *params.ChainConfig, vmConfig Config)</span> *<span class="title">EVM</span></span> &#123;</span><br><span class="line">	evm := &amp;EVM&#123;</span><br><span class="line">		Context:     ctx,</span><br><span class="line">		StateDB:     statedb,</span><br><span class="line">		vmConfig:    vmConfig,</span><br><span class="line">		chainConfig: chainConfig,</span><br><span class="line">		chainRules:  chainConfig.Rules(ctx.BlockNumber),</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主要看这个地方 创建解释器 解释器是执行字节码的关键</span></span><br><span class="line">	evm.interpreter = NewInterpreter(evm, vmConfig)</span><br><span class="line">	<span class="keyword">return</span> evm</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewInterpreter</span><span class="params">(evm *EVM, cfg Config)</span> *<span class="title">Interpreter</span></span> &#123;</span><br><span class="line">  <span class="comment">// 在这里设置 操作码对应的函数 </span></span><br><span class="line">  <span class="comment">// 主要原因是以太坊经历版本迭代之后 操作码有了一些变化</span></span><br><span class="line">  <span class="comment">// 我们移植的时候 这个地方只会保留最新版本的操作码表</span></span><br><span class="line">	<span class="keyword">if</span> !cfg.JumpTable[STOP].valid &#123;</span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> evm.ChainConfig().IsConstantinople(evm.BlockNumber):</span><br><span class="line">			cfg.JumpTable = constantinopleInstructionSet</span><br><span class="line">		<span class="keyword">case</span> evm.ChainConfig().IsByzantium(evm.BlockNumber):</span><br><span class="line">			cfg.JumpTable = byzantiumInstructionSet</span><br><span class="line">		<span class="keyword">case</span> evm.ChainConfig().IsHomestead(evm.BlockNumber):</span><br><span class="line">			cfg.JumpTable = homesteadInstructionSet</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			cfg.JumpTable = frontierInstructionSet</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> &amp;Interpreter&#123;</span><br><span class="line">		evm:      evm,</span><br><span class="line">		cfg:      cfg,</span><br><span class="line">		<span class="comment">// gas表中记录了对应的执行操作需要花费的gas 移植的时候我们只保留一个</span></span><br><span class="line">		gasTable: evm.ChainConfig().GasTable(evm.BlockNumber),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们先分析部署合约的入口， 看一看整个合约部署的流程。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create creates a new contract using code as deployment code.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(evm *EVM)</span> <span class="title">Create</span><span class="params">(caller ContractRef, code []<span class="keyword">byte</span>, gas <span class="keyword">uint64</span>, value *big.Int)</span> <span class="params">(ret []<span class="keyword">byte</span>, contractAddr common.Address, leftOverGas <span class="keyword">uint64</span>, err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 首先检测当前evm执行的深度 默认不应该超过1024  </span></span><br><span class="line">	<span class="keyword">if</span> evm.depth &gt; <span class="keyword">int</span>(params.CallCreateDepth) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, common.Address&#123;&#125;, gas, ErrDepth</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 这个函数我们不在追踪 其功能就是检测是否调用方的金额大约value</span></span><br><span class="line">	<span class="keyword">if</span> !evm.CanTransfer(evm.StateDB, caller.Address(), value) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, common.Address&#123;&#125;, gas, ErrInsufficientBalance</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 首先获取调用者的nonce 然后再更新调用者的nonce  这个如果熟悉以太坊交易流程的话应该知道nonce的作用。</span></span><br><span class="line">	nonce := evm.StateDB.GetNonce(caller.Address())</span><br><span class="line">	evm.StateDB.SetNonce(caller.Address(), nonce+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面这三句就是根据调用者地址 调用者nonce创建合约账户地址 并且判断是否这个合约地址确实没有部署过合约</span></span><br><span class="line">	contractAddr = crypto.CreateAddress(caller.Address(), nonce)</span><br><span class="line">	contractHash := evm.StateDB.GetCodeHash(contractAddr)</span><br><span class="line">	<span class="keyword">if</span> evm.StateDB.GetNonce(contractAddr) != <span class="number">0</span> || (contractHash != (common.Hash&#123;&#125;) &amp;&amp; contractHash != emptyCodeHash) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, common.Address&#123;&#125;, <span class="number">0</span>, ErrContractAddressCollision</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 既然已经创建好了合约地址 那么就要为这个合约地址创建账户体系</span></span><br><span class="line">	snapshot := evm.StateDB.Snapshot()</span><br><span class="line">	<span class="comment">// 所以下面这个函数在一直的时候我们的工作内容之一</span></span><br><span class="line">	evm.StateDB.CreateAccount(contractAddr)</span><br><span class="line">	<span class="keyword">if</span> evm.ChainConfig().IsEIP158(evm.BlockNumber) &#123;</span><br><span class="line">		evm.StateDB.SetNonce(contractAddr, <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	evm.Transfer(evm.StateDB, caller.Address(), contractAddr, value)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建一个合约对象 设置合约对象的参数 比如调用者 合约代码 合约hash的内容 </span></span><br><span class="line">	contract := NewContract(caller, AccountRef(contractAddr), value, gas)</span><br><span class="line">	contract.SetCallCode(&amp;contractAddr, crypto.Keccak256Hash(code), code)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> evm.vmConfig.NoRecursion &amp;&amp; evm.depth &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span>, contractAddr, gas, <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> evm.vmConfig.Debug &amp;&amp; evm.depth == <span class="number">0</span> &#123;</span><br><span class="line">		evm.vmConfig.Tracer.CaptureStart(caller.Address(), contractAddr, <span class="literal">true</span>, code, gas, value)</span><br><span class="line">	&#125;</span><br><span class="line">	start := time.Now()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将evm对象 合约对象传入run函数开始执行 此函数是核心 等一会分析到Call入口的时候最终也会调用此函数</span></span><br><span class="line">	ret, err = run(evm, contract, <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 上述函数执行完成后返回的就是我前一章所说的初始化后的合约代码</span></span><br><span class="line">  <span class="comment">// 也就是我们在remix上看到runtime的字节码 以后调用合约代码其实质就是</span></span><br><span class="line">  <span class="comment">// 执行返回后的代码</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面的流程主要是一些检查 把返回的字节码保存到此合约账户名下 这样以后调用合约代码才能加载成功</span></span><br><span class="line">	maxCodeSizeExceeded := evm.ChainConfig().IsEIP158(evm.BlockNumber) &amp;&amp; <span class="built_in">len</span>(ret) &gt; params.MaxCodeSize</span><br><span class="line">	<span class="comment">// if the contract creation ran successfully and no errors were returned</span></span><br><span class="line">	<span class="comment">// calculate the gas required to store the code. If the code could not</span></span><br><span class="line">	<span class="comment">// be stored due to not enough gas set an error and let it be handled</span></span><br><span class="line">	<span class="comment">// by the error checking condition below.</span></span><br><span class="line">	<span class="keyword">if</span> err == <span class="literal">nil</span> &amp;&amp; !maxCodeSizeExceeded &#123;</span><br><span class="line">		createDataGas := <span class="keyword">uint64</span>(<span class="built_in">len</span>(ret)) * params.CreateDataGas</span><br><span class="line">		<span class="keyword">if</span> contract.UseGas(createDataGas) &#123;</span><br><span class="line">			evm.StateDB.SetCode(contractAddr, ret)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			err = ErrCodeStoreOutOfGas</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// When an error was returned by the EVM or when setting the creation code</span></span><br><span class="line">	<span class="comment">// above we revert to the snapshot and consume any gas remaining. Additionally</span></span><br><span class="line">	<span class="comment">// when we&#x27;re in homestead this also counts for code storage gas errors.</span></span><br><span class="line">	<span class="keyword">if</span> maxCodeSizeExceeded || (err != <span class="literal">nil</span> &amp;&amp; (evm.ChainConfig().IsHomestead(evm.BlockNumber) || err != ErrCodeStoreOutOfGas)) &#123;</span><br><span class="line">		evm.StateDB.RevertToSnapshot(snapshot)</span><br><span class="line">		<span class="keyword">if</span> err != errExecutionReverted &#123;</span><br><span class="line">			contract.UseGas(contract.Gas)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// Assign err if contract code size exceeds the max while the err is still empty.</span></span><br><span class="line">	<span class="keyword">if</span> maxCodeSizeExceeded &amp;&amp; err == <span class="literal">nil</span> &#123;</span><br><span class="line">		err = errMaxCodeSizeExceeded</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> evm.vmConfig.Debug &amp;&amp; evm.depth == <span class="number">0</span> &#123;</span><br><span class="line">		evm.vmConfig.Tracer.CaptureEnd(ret, gas-contract.Gas, time.Since(start), err)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret, contractAddr, contract.Gas, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们下面就开始主要分析run函数</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">run</span><span class="params">(evm *EVM, contract *Contract, input []<span class="keyword">byte</span>)</span> <span class="params">([]<span class="keyword">byte</span>, error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> contract.CodeAddr != <span class="literal">nil</span> &#123;</span><br><span class="line">	  <span class="comment">// 首先会进入下面这个代码执行  它会根据给定的合约地址来判断是否是以太坊内部已经保存的合约</span></span><br><span class="line">	  <span class="comment">// 如果是创建新合约 肯定不是内置合约</span></span><br><span class="line">		precompiles := PrecompiledContractsHomestead</span><br><span class="line">		<span class="keyword">if</span> evm.ChainConfig().IsByzantium(evm.BlockNumber) &#123;</span><br><span class="line">			precompiles = PrecompiledContractsByzantium</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> p := precompiles[*contract.CodeAddr]; p != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> RunPrecompiledContract(p, input, contract)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 所以最后我们最终到这里 此时input参数为nil</span></span><br><span class="line">	<span class="keyword">return</span> evm.interpreter.Run(contract, input)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解释器的Run函数才是真正执行合约代码的地方</span></span><br><span class="line"><span class="comment">// 为了凸显主流程 我们隐藏部分内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(in *Interpreter)</span> <span class="title">Run</span><span class="params">(contract *Contract, input []<span class="keyword">byte</span>)</span> <span class="params">(ret []<span class="keyword">byte</span>, err error)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> in.intPool == <span class="literal">nil</span> &#123;</span><br><span class="line">		in.intPool = poolOfIntPools.get()</span><br><span class="line">		<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">			poolOfIntPools.put(in.intPool)</span><br><span class="line">			in.intPool = <span class="literal">nil</span></span><br><span class="line">		&#125;()</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 下面这些变量应该说满足了一个字节码执行的所有条件</span></span><br><span class="line">	<span class="comment">// 有操作码 内存 栈 PC计数器 </span></span><br><span class="line">	<span class="comment">// 强烈建议使用debug工具去跟踪一遍执行的流程 </span></span><br><span class="line">	<span class="comment">// 其实它的执行流程就和上一章我们人肉执行的流程一样</span></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		op    OpCode        <span class="comment">// current opcode</span></span><br><span class="line">		mem   = NewMemory() <span class="comment">// bound memory</span></span><br><span class="line">		stack = newstack()  <span class="comment">// local stack</span></span><br><span class="line">		pc   = <span class="keyword">uint64</span>(<span class="number">0</span>) <span class="comment">// program counter</span></span><br><span class="line">		cost <span class="keyword">uint64</span></span><br><span class="line">		pcCopy  <span class="keyword">uint64</span> <span class="comment">// needed for the deferred Tracer</span></span><br><span class="line">		gasCopy <span class="keyword">uint64</span> <span class="comment">// for Tracer to log gas remaining before execution</span></span><br><span class="line">		logged  <span class="keyword">bool</span>   <span class="comment">// deferred Tracer should ignore already logged steps</span></span><br><span class="line">	)</span><br><span class="line">	contract.Input = input</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Reclaim the stack as an int pool when the execution stops</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; in.intPool.put(stack.data...) &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始循环PC计数执行 直到有中止执行或者跳出循环</span></span><br><span class="line">	<span class="keyword">for</span> atomic.LoadInt32(&amp;in.evm.abort) == <span class="number">0</span> &#123;</span><br><span class="line">    <span class="comment">// 根据PC计数器获取操作码</span></span><br><span class="line">		op = contract.GetOp(pc)</span><br><span class="line">		<span class="comment">// 根据操作码获取对应的操作函数</span></span><br><span class="line">		operation := in.cfg.JumpTable[op]</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 验证栈中的数据是否符合操作码需要的数据</span></span><br><span class="line">		<span class="keyword">if</span> err := operation.validateStack(stack); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// If the operation is valid, enforce and write restrictions</span></span><br><span class="line">		<span class="keyword">if</span> err := in.enforceRestrictions(op, operation, stack); err != <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">var</span> memorySize <span class="keyword">uint64</span></span><br><span class="line">		<span class="comment">// 有些指令是需要额外的内存消耗 在jump_table.go文件中可以看到他们具体每个操作码的对应的额外内存消耗计算</span></span><br><span class="line">		<span class="comment">// 并不是所有的指令都需要计算消耗的内存 </span></span><br><span class="line">		<span class="comment">// memorySize指向对应的计算消耗内存的函数 根据消耗的内存来计算消费的gas</span></span><br><span class="line">		<span class="keyword">if</span> operation.memorySize != <span class="literal">nil</span> &#123;</span><br><span class="line">			memSize, overflow := bigUint64(operation.memorySize(stack))</span><br><span class="line">			<span class="keyword">if</span> overflow &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, errGasUintOverflow</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> memorySize, overflow = math.SafeMul(toWordSize(memSize), <span class="number">32</span>); overflow &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">nil</span>, errGasUintOverflow</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 计算此操作花费的gas数量</span></span><br><span class="line">		cost, err = operation.gasCost(in.gasTable, in.evm, contract, stack, mem, memorySize)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> || !contract.UseGas(cost) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, ErrOutOfGas</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> memorySize &gt; <span class="number">0</span> &#123;</span><br><span class="line">			mem.Resize(memorySize)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 开始执行此操作码对应的操作函数 同时会返回执行结果同时也会更新PC计数器 </span></span><br><span class="line">		<span class="comment">// 大部分的操作码对应的操作函数都是在instructions.go中可以找得到</span></span><br><span class="line">		res, err := operation.execute(&amp;pc, in.evm, contract, mem, stack)</span><br><span class="line">    <span class="comment">// 如果这个操作码是一个返回参数 那么就把需要的内容写入returnData</span></span><br><span class="line">    <span class="comment">// 按理说应该是只有return参数才会有范湖</span></span><br><span class="line">		<span class="keyword">if</span> operation.returns &#123;</span><br><span class="line">			in.returnData = res</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 到这里也就意味着一个操作码已经执行完成了 应该根据这次的执行结果来决定下一步的动作</span></span><br><span class="line">    <span class="comment">// 1. 如果执行出错了 直接返回错误</span></span><br><span class="line">    <span class="comment">// 2. 如果只能合约代码中止了(比如断言失败) 那么直接返回执行结果 </span></span><br><span class="line">    <span class="comment">// 3. 如果是暂停指令 则直接返回结果</span></span><br><span class="line">    <span class="comment">// 4. 如果操作符不是一个跳转 则直接PC指向下一个指令 继续循环执行</span></span><br><span class="line">		<span class="keyword">switch</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> err != <span class="literal">nil</span>:</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">		<span class="keyword">case</span> operation.reverts:</span><br><span class="line">			<span class="keyword">return</span> res, errExecutionReverted</span><br><span class="line">		<span class="keyword">case</span> operation.halts:</span><br><span class="line">			<span class="keyword">return</span> res, <span class="literal">nil</span></span><br><span class="line">		<span class="keyword">case</span> !operation.jumps:</span><br><span class="line">			pc++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span>, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到了这里整个部署合约流程就完成了, 部署合约时是从evm.Create-&gt;run-&gt;interper.run 然后在执行codeCopy指令后把runtime的内容返回出来。 在evm.Create函数中我们也看到了当run执行完成后会把runtime的合约代码最终设置到合约地址名下。 整个合约部署就算完成了。</p>
<p>分析完合约创建接着就该分析合约调用代码了。 调用智能合约和部署在以太坊交易上看来就是to的地址不在是nil而是一个具体的合约地址了。 同时input的内容不再是整个合约编译后的字节码了而是调用函数和对应的实参组合的内容。 这里就涉及到另一个东西那就是abi的概念。此处我不打算详细说明， abi描述了整个接口的详细信息， 根据abi可以解包和打包input调用的数据。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 忽略一些隐藏了主线的内容</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(evm *EVM)</span> <span class="title">Call</span><span class="params">(caller ContractRef, addr common.Address, input []<span class="keyword">byte</span>, gas <span class="keyword">uint64</span>, value *big.Int)</span> <span class="params">(ret []<span class="keyword">byte</span>, leftOverGas <span class="keyword">uint64</span>, err error)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> (</span><br><span class="line">		to       = AccountRef(addr)</span><br><span class="line">		snapshot = evm.StateDB.Snapshot()</span><br><span class="line">	)</span><br><span class="line">	<span class="comment">// 首先要判断这个合约地址是否存在 如果不存在是否是内置的合约 </span></span><br><span class="line">	<span class="keyword">if</span> !evm.StateDB.Exist(addr) &#123;</span><br><span class="line">		precompiles := PrecompiledContractsHomestead</span><br><span class="line">		<span class="keyword">if</span> evm.ChainConfig().IsByzantium(evm.BlockNumber) &#123;</span><br><span class="line">			precompiles = PrecompiledContractsByzantium</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> precompiles[addr] == <span class="literal">nil</span> &amp;&amp; evm.ChainConfig().IsEIP158(evm.BlockNumber) &amp;&amp; value.Sign() == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="comment">// Calling a non existing account, don&#x27;t do antything, but ping the tracer</span></span><br><span class="line">			<span class="keyword">if</span> evm.vmConfig.Debug &amp;&amp; evm.depth == <span class="number">0</span> &#123;</span><br><span class="line">				evm.vmConfig.Tracer.CaptureStart(caller.Address(), addr, <span class="literal">false</span>, input, gas, value)</span><br><span class="line">				evm.vmConfig.Tracer.CaptureEnd(ret, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">nil</span>)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span>, gas, <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line">		evm.StateDB.CreateAccount(addr)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 执行进行以太币的转账过程</span></span><br><span class="line">	evm.Transfer(evm.StateDB, caller.Address(), to.Address(), value)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是不是很熟悉 不管是部署合约还是调用合约都要先创建合约对象 把合约加载出来挂到合约对象下</span></span><br><span class="line">	contract := NewContract(caller, to, value, gas)</span><br><span class="line">	contract.SetCallCode(&amp;addr, evm.StateDB.GetCodeHash(addr), evm.StateDB.GetCode(addr))</span><br><span class="line"></span><br><span class="line">	start := time.Now()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 依然是调用run函数来执行代码 不同之处在于这次的input不在是nil了 而是交易的input内容</span></span><br><span class="line">  <span class="comment">// 在上一节中我们看到CALLDATALOAD这个指令会用到input的内容</span></span><br><span class="line">	ret, err = run(evm, contract, input)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		evm.StateDB.RevertToSnapshot(snapshot)</span><br><span class="line">		<span class="keyword">if</span> err != errExecutionReverted &#123;</span><br><span class="line">			contract.UseGas(contract.Gas)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 最终返回执行结果</span></span><br><span class="line">	<span class="keyword">return</span> ret, contract.Gas, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应该说到了这里只能合约流程就完事了， 可是也许你会好奇命名evm里面有那么多的内容没有分析到。 但是整个流程确实就是这些。 其他的比如栈对象是如何模拟的， 内存是如何模拟的。 操作码对应的操作函数，及其相关gas花费怎么计算的都没有说明。 可是我觉得首先知道整个流程和原理。阅读这些就比较容易了， 因为我们知道目的和原理， 就会明白它的那些代码的作用了。 如果我上去就说那些东西， 整个主线就会被淹没了。</p>
<p>最后还有一个比较重要的接口要说明一下， 它是我们接下来移植中要重点修改的内容。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> StateDB <span class="keyword">interface</span> &#123;</span><br><span class="line">  <span class="comment">// 创建账户函数 表明evm需要你执行创建一个新的账户体系</span></span><br><span class="line">	CreateAccount(common.Address)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 减去一个账户的余额</span></span><br><span class="line">	SubBalance(common.Address, *big.Int)</span><br><span class="line">	<span class="comment">// 添加一个账户的余额</span></span><br><span class="line">	AddBalance(common.Address, *big.Int)</span><br><span class="line">	<span class="comment">// 获取一个账户的余额</span></span><br><span class="line">	GetBalance(common.Address) *big.Int</span><br><span class="line">  <span class="comment">// 获取账户的nonce 因为以太坊要根据nonce在决定交易的执行顺序和合约地址的生成</span></span><br><span class="line">	GetNonce(common.Address) <span class="keyword">uint64</span></span><br><span class="line">	<span class="comment">// 更新合约的nonce</span></span><br><span class="line">	SetNonce(common.Address, <span class="keyword">uint64</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取合约地址的整个合约代码的hash值</span></span><br><span class="line">	GetCodeHash(common.Address) common.Hash</span><br><span class="line">	<span class="comment">// 获取合约代码</span></span><br><span class="line">	GetCode(common.Address) []<span class="keyword">byte</span></span><br><span class="line">	<span class="comment">// 设置合约代码</span></span><br><span class="line">	SetCode(common.Address, []<span class="keyword">byte</span>)</span><br><span class="line">	<span class="comment">// 获取合约代码的大小</span></span><br><span class="line">	GetCodeSize(common.Address) <span class="keyword">int</span></span><br><span class="line">  <span class="comment">// 获取和添加偿还金额</span></span><br><span class="line">	AddRefund(<span class="keyword">uint64</span>)</span><br><span class="line">	GetRefund() <span class="keyword">uint64</span></span><br><span class="line">  <span class="comment">// 注意这两个函数很重要 其实质就是相当于数据库的select和update </span></span><br><span class="line">  <span class="comment">// 一个智能合约的全局静态数据的读取和写入就是通过这两个函数</span></span><br><span class="line">	GetState(common.Address, common.Hash) common.Hash</span><br><span class="line">	SetState(common.Address, common.Hash, common.Hash)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 合约账户自杀 或者是否已经自杀 主要是以太坊的一个机制 自杀的合约会给与退费</span></span><br><span class="line">	Suicide(common.Address) <span class="keyword">bool</span></span><br><span class="line">	HasSuicided(common.Address) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断一个合约是否存在</span></span><br><span class="line">	Exist(common.Address) <span class="keyword">bool</span></span><br><span class="line">	<span class="comment">// 判断合约是否为空</span></span><br><span class="line">	<span class="comment">// is defined according to EIP161 (balance = nonce = code = 0).</span></span><br><span class="line">	Empty(common.Address) <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">	RevertToSnapshot(<span class="keyword">int</span>)</span><br><span class="line">	Snapshot() <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 此函数就是在我们在智能合约中执行emit命令时调用的</span></span><br><span class="line">	AddLog(*types.Log)</span><br><span class="line">	AddPreimage(common.Hash, []<span class="keyword">byte</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这个接口在evm中没有使用到 我们可以写一个空函数</span></span><br><span class="line">	ForEachStorage(common.Address, <span class="function"><span class="keyword">func</span><span class="params">(common.Hash, common.Hash)</span> <span class="title">bool</span>)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此整个evm分析就结束了, </p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://willzhuang.github.io/2019/03/20/evm%E4%B9%8B%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" data-id="ckh0c7eof00azxgvm5wqabdhm" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/EVM/" rel="tag">EVM</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/03/20/%E5%85%B3%E4%BA%8E%E7%A8%B3%E5%AE%9A%E4%BB%A3%E5%B8%81%E7%9A%84%E8%AF%B4%E6%98%8E/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          关于稳定代币的说明
        
      </div>
    </a>
  
  
    <a href="/2018/12/28/OCR%E5%92%8Ctesseract%E9%A1%B9%E7%9B%AE/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">OCR和tesseract项目</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/ACL/" rel="tag">ACL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Burrow/" rel="tag">Burrow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/CSC/" rel="tag">CSC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DAO/" rel="tag">DAO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DFINITY/" rel="tag">DFINITY</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DID/" rel="tag">DID</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EIP/" rel="tag">EIP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/EVM/" rel="tag">EVM</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ethereum/" rel="tag">Ethereum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Ghana/" rel="tag">Ghana</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Haproxy/" rel="tag">Haproxy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JWT/" rel="tag">JWT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OCR/" rel="tag">OCR</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OpenPGP/" rel="tag">OpenPGP</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/PBFT/" rel="tag">PBFT</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ProtoBuf/" rel="tag">ProtoBuf</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Tensorflow/" rel="tag">Tensorflow</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Token/" rel="tag">Token</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/VRF/" rel="tag">VRF</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WebAssembly/" rel="tag">WebAssembly</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorand/" rel="tag">algorand</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/chainlink/" rel="tag">chainlink</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/channel/" rel="tag">channel</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/credits/" rel="tag">credits</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/cv/" rel="tag">cv</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/debug/" rel="tag">debug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/disk-usage/" rel="tag">disk usage</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ethereum/" rel="tag">ethereum</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/gRPC/" rel="tag">gRPC</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/geth/" rel="tag">geth</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang%E6%9C%8D%E5%8A%A1/" rel="tag">golang服务</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/google/" rel="tag">google</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/k8s/" rel="tag">k8s</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/leadership/" rel="tag">leadership</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/make/" rel="tag">make</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/paper/" rel="tag">paper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pbft/" rel="tag">pbft</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pprof/" rel="tag">pprof</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/raft/" rel="tag">raft</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/remix/" rel="tag">remix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/seaweedfs/" rel="tag">seaweedfs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/solidity/" rel="tag">solidity</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/wasm/" rel="tag">wasm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/whisper/" rel="tag">whisper</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%93%E5%88%A9/" rel="tag">专利</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1/" rel="tag">产品设计</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BB%A4%E7%89%8C%E7%8E%AF%E9%A2%86%E5%AF%BC%E4%BA%BA%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95/" rel="tag">令牌环领导人选举算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%8D%A0%E7%94%A8%E7%A3%81%E7%9B%98/" rel="tag">占用磁盘</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/" rel="tag">商业模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%95%86%E5%93%81%E9%AA%8C%E7%9C%9F/" rel="tag">商品验真</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90/" rel="tag">开源</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/" rel="tag">开源协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" rel="tag">性能分析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%83%85%E5%95%86/" rel="tag">情商</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%88%90%E5%8A%9F/" rel="tag">成功</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%97%E8%B5%84%E4%BA%A7/" rel="tag">数字资产</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/" rel="tag">数学符号</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80/" rel="tag">服务器地址</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/" rel="tag">架构模式</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%94%B5%E5%95%86/" rel="tag">电商</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9B%B8%E4%BC%BC%E5%BA%A6/" rel="tag">相似度</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/" rel="tag">知识图谱</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%A3%81%E7%9B%98/" rel="tag">磁盘</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/" rel="tag">网络攻击</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/" rel="tag">随机数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%90%E7%A7%81/" rel="tag">隐私</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/" rel="tag">零知识证明</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%A2%86%E5%AF%BC%E4%BA%BA%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95/" rel="tag">领导人选举算法</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/ACL/" style="font-size: 10px;">ACL</a> <a href="/tags/Burrow/" style="font-size: 13.33px;">Burrow</a> <a href="/tags/CSC/" style="font-size: 15.56px;">CSC</a> <a href="/tags/DAO/" style="font-size: 10px;">DAO</a> <a href="/tags/DFINITY/" style="font-size: 10px;">DFINITY</a> <a href="/tags/DID/" style="font-size: 10px;">DID</a> <a href="/tags/EIP/" style="font-size: 10px;">EIP</a> <a href="/tags/EVM/" style="font-size: 10px;">EVM</a> <a href="/tags/Ethereum/" style="font-size: 17.78px;">Ethereum</a> <a href="/tags/Ghana/" style="font-size: 15.56px;">Ghana</a> <a href="/tags/Haproxy/" style="font-size: 10px;">Haproxy</a> <a href="/tags/JWT/" style="font-size: 10px;">JWT</a> <a href="/tags/OCR/" style="font-size: 11.11px;">OCR</a> <a href="/tags/OpenPGP/" style="font-size: 10px;">OpenPGP</a> <a href="/tags/PBFT/" style="font-size: 10px;">PBFT</a> <a href="/tags/ProtoBuf/" style="font-size: 10px;">ProtoBuf</a> <a href="/tags/Tensorflow/" style="font-size: 14.44px;">Tensorflow</a> <a href="/tags/Token/" style="font-size: 16.67px;">Token</a> <a href="/tags/VRF/" style="font-size: 11.11px;">VRF</a> <a href="/tags/WebAssembly/" style="font-size: 10px;">WebAssembly</a> <a href="/tags/algorand/" style="font-size: 11.11px;">algorand</a> <a href="/tags/chainlink/" style="font-size: 10px;">chainlink</a> <a href="/tags/channel/" style="font-size: 10px;">channel</a> <a href="/tags/credits/" style="font-size: 10px;">credits</a> <a href="/tags/cv/" style="font-size: 11.11px;">cv</a> <a href="/tags/debug/" style="font-size: 10px;">debug</a> <a href="/tags/disk-usage/" style="font-size: 11.11px;">disk usage</a> <a href="/tags/ethereum/" style="font-size: 12.22px;">ethereum</a> <a href="/tags/gRPC/" style="font-size: 10px;">gRPC</a> <a href="/tags/geth/" style="font-size: 10px;">geth</a> <a href="/tags/golang%E6%9C%8D%E5%8A%A1/" style="font-size: 10px;">golang服务</a> <a href="/tags/google/" style="font-size: 14.44px;">google</a> <a href="/tags/k8s/" style="font-size: 11.11px;">k8s</a> <a href="/tags/leadership/" style="font-size: 10px;">leadership</a> <a href="/tags/make/" style="font-size: 10px;">make</a> <a href="/tags/paper/" style="font-size: 13.33px;">paper</a> <a href="/tags/pbft/" style="font-size: 11.11px;">pbft</a> <a href="/tags/pprof/" style="font-size: 11.11px;">pprof</a> <a href="/tags/raft/" style="font-size: 10px;">raft</a> <a href="/tags/remix/" style="font-size: 10px;">remix</a> <a href="/tags/seaweedfs/" style="font-size: 10px;">seaweedfs</a> <a href="/tags/solidity/" style="font-size: 17.78px;">solidity</a> <a href="/tags/wasm/" style="font-size: 11.11px;">wasm</a> <a href="/tags/whisper/" style="font-size: 10px;">whisper</a> <a href="/tags/%E4%B8%93%E5%88%A9/" style="font-size: 10px;">专利</a> <a href="/tags/%E4%BA%A7%E5%93%81%E8%AE%BE%E8%AE%A1/" style="font-size: 18.89px;">产品设计</a> <a href="/tags/%E4%BB%A4%E7%89%8C%E7%8E%AF%E9%A2%86%E5%AF%BC%E4%BA%BA%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95/" style="font-size: 10px;">令牌环领导人选举算法</a> <a href="/tags/%E5%8D%A0%E7%94%A8%E7%A3%81%E7%9B%98/" style="font-size: 11.11px;">占用磁盘</a> <a href="/tags/%E5%95%86%E4%B8%9A%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">商业模式</a> <a href="/tags/%E5%95%86%E5%93%81%E9%AA%8C%E7%9C%9F/" style="font-size: 10px;">商品验真</a> <a href="/tags/%E5%BC%80%E6%BA%90/" style="font-size: 10px;">开源</a> <a href="/tags/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE/" style="font-size: 10px;">开源协议</a> <a href="/tags/%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/" style="font-size: 10px;">性能分析</a> <a href="/tags/%E6%83%85%E5%95%86/" style="font-size: 10px;">情商</a> <a href="/tags/%E6%88%90%E5%8A%9F/" style="font-size: 10px;">成功</a> <a href="/tags/%E6%95%B0%E5%AD%97%E8%B5%84%E4%BA%A7/" style="font-size: 12.22px;">数字资产</a> <a href="/tags/%E6%95%B0%E5%AD%A6%E7%AC%A6%E5%8F%B7/" style="font-size: 10px;">数学符号</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%9C%B0%E5%9D%80/" style="font-size: 10px;">服务器地址</a> <a href="/tags/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/" style="font-size: 10px;">架构模式</a> <a href="/tags/%E7%94%B5%E5%95%86/" style="font-size: 10px;">电商</a> <a href="/tags/%E7%9B%B8%E4%BC%BC%E5%BA%A6/" style="font-size: 10px;">相似度</a> <a href="/tags/%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1/" style="font-size: 10px;">知识图谱</a> <a href="/tags/%E7%A3%81%E7%9B%98/" style="font-size: 10px;">磁盘</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%BD%91%E7%BB%9C%E6%94%BB%E5%87%BB/" style="font-size: 10px;">网络攻击</a> <a href="/tags/%E9%9A%8F%E6%9C%BA%E6%95%B0/" style="font-size: 10px;">随机数</a> <a href="/tags/%E9%9A%90%E7%A7%81/" style="font-size: 10px;">隐私</a> <a href="/tags/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E/" style="font-size: 20px;">零知识证明</a> <a href="/tags/%E9%A2%86%E5%AF%BC%E4%BA%BA%E9%80%89%E4%B8%BE%E7%AE%97%E6%B3%95/" style="font-size: 10px;">领导人选举算法</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/01/">January 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/04/">April 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2012/06/">June 2012</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2011/11/">November 2011</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/11/">November 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2010/10/">October 2010</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/1982/02/">February 1982</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/10/29/%E4%B8%87%E5%90%91%E7%9A%84%E4%BA%A7%E4%B8%9A%E5%8C%BA%E5%9D%97%E9%93%BE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/">万向的产业区块链解决方</a>
          </li>
        
          <li>
            <a href="/2020/10/29/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%AC%AC%E4%BA%8C%E5%B1%82%E5%8D%8F%E8%AE%AE%E7%94%9F%E6%80%81%E7%9A%84%E5%B4%9B%E8%B5%B7/">以太坊第二层协议生态的崛起</a>
          </li>
        
          <li>
            <a href="/2020/10/29/%E6%89%93%E9%80%A0%E6%95%B0%E5%AD%97%E7%BB%8F%E6%B5%8E%E6%96%B0%E5%9F%BA%E5%BB%BA%E8%A7%A3%E6%94%BE%E6%95%B0%E6%8D%AE%E7%94%9F%E4%BA%A7%E5%8A%9B/">打造数字经济新基建解放数据生产力</a>
          </li>
        
          <li>
            <a href="/2020/10/29/%E5%8C%BA%E5%9D%97%E9%93%BE%E5%BA%94%E7%94%A8%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%88%E6%9E%81%E7%8C%9C%E6%83%B3/">区块链应用模式的终极猜想</a>
          </li>
        
          <li>
            <a href="/2020/09/18/%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6-%E9%80%80%E6%AC%BE%E6%96%B9%E5%BC%8F/">智能合约-退款方式</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 Weiming Zhuang<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>